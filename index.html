<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Old+Mincho&display=swap" rel="stylesheet">
    <title>誤字ロマの日記</title>
    <link rel="icon" href="diary-icon.png" type="image/png">
    <style>
        :root {
            --bg-color: #e6f3ff;
            --text-color: #003366;
            --border-color: #003366;
            --timeline-color: #003366;
            --highlight-color: #ffeb3b;
        }

        body {
            font-family: "Zen Old Mincho", serif;
            font-weight: 400;
            font-style: normal;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100svh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
            opacity: 0;
            transition: opacity 0.2s ease, background-color 0.2s ease;
            background-color: var(--bg-color);
        }

        body.fake-mode {
            --bg-color: #000;
            --text-color: #fff;
            --border-color: #fff;
            --timeline-color: #fff;
            --highlight-color: #ffc107;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .page-title {
            color: var(--text-color);
            position: fixed;
            top: 10px;
            right: 20px;
            font-family: "Zen Old Mincho", serif;
            font-size: 18px;
            font-weight: 700;
            border: 1px solid var(--border-color);
            padding: 5px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s;
            text-decoration: none;
            opacity: 0.6;
            z-index: 10;
            user-select: none;
        }

        .page-title:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        .page-title.fake-mode {
            background-color: var(--bg-color);
            color: var(--text-color);
            border-color: var(--border-color);
        }

        .page-title.flash {
            background-color: #000 !important;
            color: #ff0 !important;
            border-color: #ff0 !important;
        }

        input[type="text"] {
            color: var(--text-color) !important;
            font-family: "Zen Old Mincho", serif;
            position: fixed;
            top: 10px;
            left: 20px;
            padding: 5px 10px;
            border-radius: 8px;
            width: 7ic;
            background-color: var(--bg-color);
            font-family: "Zen Old Mincho", serif;
            font-size: 18px;
            font-weight: 700;
            border: 1px solid var(--border-color);
            padding: 5px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s;
            text-decoration: none;
            opacity: 0.6;
            z-index: 10;
            user-select: none;
            outline: none;
        }

        ::placeholder {
            color: var(--text-color);
            opacity: 0.4;
        }

        .fake-mode ::placeholder {
            color: var(--text-color);
            opacity: 0.4;
        }

        .fake-mode .search-box,
        .fake-mode input[type="text"] {
            color: var(--text-color);
            background-color: var(--bg-color);
            border-color: var(--border-color);
        }

        .diary-container-wrapper {
            width: 100%;
            max-width: 90%;
            height: 78vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            box-sizing: border-box;
            margin-top: 20px;
            transition: background-color 0.2s ease;
            background-color: var(--bg-color);
        }

        .diary-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            height: 100%;
            padding: 0;
            overflow-x: auto;
            scrollbar-width: none;
        }

        ::-webkit-scrollbar {
            display: none;
        }

        .diary-entry {
            writing-mode: vertical-rl;
            text-orientation: upright;
            line-height: 2;
            letter-spacing: 0.1em;
            width: auto;
            white-space: normal;
            overflow: visible;
            scroll-margin-top: 50px;
            padding: 0 10px;
            transition: all 0.3s ease;
            flex-shrink: 0;
            text-wrap: balance;
            overflow-wrap: break-word;
            background-color: transparent;
            position: relative;
        }

        .date-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            margin-right: 20px;
            margin-left: 20px;
            flex-wrap: wrap;
            gap: 5px;
        }

        .date {
            font-family: "Zen Old Mincho", serif;
            font-size: 1.6em;
            cursor: pointer;
            color: var(--text-color);
            white-space: nowrap;
        }

        .days-ago {
            font-family: "Zen Old Mincho", serif;
            font-size: 0.8em;
            color: var(--text-color);
            margin-left: 8px;
            white-space: nowrap;
            opacity: 0.7;
        }

        .content {
            font-family: "Zen Old Mincho", serif;
            font-size: 1.3em;
            white-space: pre-line;
            text-wrap: balance;
            overflow-wrap: break-word;
            color: var(--text-color);
        }

        .highlight {
            background-color: var(--highlight-color);
            font-weight: bold;
            padding: 0 2px;
            border-radius: 2px;
            margin: 0 -2px;
        }

        .timeline-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 0 10%;
            box-sizing: border-box;
            touch-action: none;
        }

        @media (max-width: 768px) {
            .timeline-container {
                height: 20px;
            }
        }

        .timeline {
            position: relative;
            display: flex;
            flex-direction: row-reverse;
            justify-content: center;
            align-items: flex-end;
            height: 100%;
            width: 100%;
            opacity: 0.2;
            transition: opacity 0.2s;
        }

        .timeline:hover {
            opacity: 1;
        }

        .timeline-bar {
            width: 8px;
            height: 100%;
            margin: 0 1px;
            background-color: transparent;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
        }

        .timeline-bar-inner {
            width: 100%;
            background-color: var(--text-color);
            transition: background-color 0.2s;
        }

        .timeline-bar:hover .timeline-bar-inner {
            background-color: #ff9900 !important;
        }

        @keyframes lanternOutline {
            0% {
                outline-color: #ff0000;
            }

            25% {
                outline-color: #00ff00;
            }

            50% {
                outline-color: #0000ff;
            }

            75% {
                outline-color: #ffff00;
            }

            100% {
                outline-color: #ff00ff;
            }
        }

        .search-box.lantern-mode {
            outline: 2px solid transparent;
            animation: lanternOutline 4s linear infinite;
        }

        @keyframes lanternBackground {
            0% {
                background-color: rgba(255, 0, 0, 0.2);
            }

            25% {
                background-color: rgba(0, 255, 0, 0.2);
            }

            50% {
                background-color: rgba(0, 0, 255, 0.2);
            }

            75% {
                background-color: rgba(255, 255, 0, 0.2);
            }

            100% {
                background-color: rgba(255, 0, 255, 0.2);
            }
        }

        @keyframes lanternText {
            0% {
                color: #ff0000;
            }

            25% {
                color: #00ff00;
            }

            50% {
                color: #0000ff;
            }

            75% {
                color: #ffff00;
            }

            100% {
                color: #ff00ff;
            }
        }

        .search-box.lantern-mode {
            outline: 2px solid transparent;
            animation: lanternOutline 4s linear infinite, lanternBackground 4s linear infinite, lanternText 4s linear infinite;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }

        /* アイコン用スタイル */
        .icon {
            width: 34px;
            height: 34px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s, background-color 0.2s, filter 0.2s;
            border-radius: 4px;
        }

        .icon:hover {
            transform: scale(1.1);
            z-index: 20;
        }

        .icon.highlight {
            background-color: var(--highlight-color);
            filter: brightness(0.85);
        }

        .icon img {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
        }

        span.icon-emoji,
        img.icon-img {
            font-size: x-large;
            filter: grayscale(84%);
            opacity: 0.4;
        }

        /* ツールチップ用スタイル */
        .tooltip {
            position: absolute;
            top: -50%;
            left: 140%;
            transform: translateX(-50%);
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            border: 1px solid var(--border-color);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 30;
            margin-bottom: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-family: "Zen Old Mincho", serif;
        }

        .icon:hover .tooltip {
            opacity: 1;
        }
    </style>
</head>

<body>
    <input type="text" class="search-box" placeholder="検索or二度押し">
    <div class="page-title" id="pageTitle">誤字ロマの日記</div>
    <div class="diary-container-wrapper">
        <div class="diary-container" id="diaryContainer"></div>
    </div>
    <div class="timeline-container">
        <div class="timeline" id="timeline"></div>
    </div>

    <script>
        // ===== Utilities =====
        class DiaryUtils {
            static toKanjiNumber(num) {
                const kanjiNumbers = ['〇', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
                return num.toString().split('').map(digit => kanjiNumbers[digit]).join('');
            }

            static toKanjiMonth(month) {
                const kanjiMonths = [
                    '一月', '二月', '三月', '四月', '五月', '六月',
                    '七月', '八月', '九月', '十月', '十一月', '十二月'
                ];
                return kanjiMonths[month - 1];
            }

            static toKanjiDay(day) {
                if (day === 10) return '十';
                if (day === 20) return '二十';
                if (day === 30) return '三十';
                if (day === 31) return '三十一';
                if (day < 10) return this.toKanjiNumber(day);
                if (day < 20) return '十' + this.toKanjiNumber(day - 10);
                if (day < 30) return '二十' + this.toKanjiNumber(day - 20);
                return this.toKanjiNumber(day);
            }

            static toJapaneseEra(year) {
                if (year >= 2019) {
                    const eraYear = year - 2018;
                    return `令和${this.toKanjiNumber(eraYear)}年`;
                } else if (year >= 1989) {
                    const eraYear = year - 1988;
                    return `平成${this.toKanjiNumber(eraYear)}年`;
                } else if (year >= 1926) {
                    const eraYear = year - 1925;
                    return `昭和${this.toKanjiNumber(eraYear)}年`;
                } else if (year >= 1912) {
                    const eraYear = year - 1911;
                    return `大正${this.toKanjiNumber(eraYear)}年`;
                } else {
                    const eraYear = year - 1867;
                    return `明治${this.toKanjiNumber(eraYear)}年`;
                }
            }

            static formatJapaneseDate(yyyymmdd) {
                const year = parseInt(yyyymmdd.substring(0, 4), 10);
                const month = parseInt(yyyymmdd.substring(4, 6), 10);
                const day = parseInt(yyyymmdd.substring(6, 8), 10);
                const date = new Date(year, month - 1, day);
                const dayOfWeek = ['日', '月', '火', '水', '木', '金', '土'][date.getDay()];
                return {
                    short: `${this.toKanjiMonth(month)}${this.toKanjiDay(day)}日（${DiaryApp.isFakeMode ? '嘘' : dayOfWeek}）`,
                    long: `${this.toJapaneseEra(year)}${this.toKanjiMonth(month)}${this.toKanjiDay(day)}日（${DiaryApp.isFakeMode ? '嘘' : dayOfWeek}）`
                };
            }

            static generateRandomDate() {
                const today = new Date();
                const randomDaysAgo = Math.floor(Math.random() * 60) + 1;
                const randomDate = new Date(today);
                randomDate.setDate(today.getDate() - randomDaysAgo);
                const year = randomDate.getFullYear();
                const month = String(randomDate.getMonth() + 1).padStart(2, '0');
                const day = String(randomDate.getDate()).padStart(2, '0');
                return `${year}${month}${day}`;
            }

            static calculateDaysAgo(yyyymmdd) {
                const year = parseInt(yyyymmdd.substring(0, 4), 10);
                const month = parseInt(yyyymmdd.substring(4, 6), 10) - 1;
                const day = parseInt(yyyymmdd.substring(6, 8), 10);
                const entryDate = new Date(year, month, day);
                const today = new Date();
                const diffTime = today - entryDate;
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                return diffDays === 0 ? '今日' : `${diffDays}日前`;
            }

            static escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            static highlightText(text, keyword) {
                if (!keyword.trim()) return text;
                const regex = new RegExp(this.escapeRegExp(keyword), 'gi');
                return text.replace(regex, match => `<span class="highlight">${match}</span>`);
            }
        }

        // ===== App Class =====
        class DiaryApp {
            static THEMES = [
                { bg: "#e6f3ff", text: "#003366", border: "#003366" },
                { bg: "#fff8e6", text: "#8b4513", border: "#8b4513" },
                { bg: "#e6ffe6", text: "#2e8b57", border: "#2e8b57" },
                { bg: "#ffe6f0", text: "#8b008b", border: "#8b008b" },
                { bg: "#f0f0ff", text: "#4b0082", border: "#4b0082" },
                { bg: "#ffffe6", text: "#b8860b", border: "#b8860b" },
                { bg: "#e6ffff", text: "#0066cc", border: "#0066cc" },
                { bg: "#f0e6ff", text: "#800080", border: "#800080" },
                { bg: "#fff0e6", text: "#cd5c5c", border: "#cd5c5c" },
                { bg: "#f0ffe6", text: "#228b22", border: "#228b22" }
            ];

            static currentTheme = null;
            static isFakeMode = false;
            static fakeEntriesCache = null;
            static diaryEntries = [];
            static eventListeners = [];
            static currentSearchKeyword = '';
            static iconsData = [];
            static isLanternMode = false;
            static lanternModeInterval = null;

            static init() {
                this.applyRandomTheme();
                this.loadIconsData();
                this.loadDiaryEntries();
                this.preloadFakeEntries();
                this.setupEventListeners();
                document.body.style.opacity = 1;
            }

            static applyRandomTheme() {
                const randomTheme = this.THEMES[Math.floor(Math.random() * this.THEMES.length)];
                this.currentTheme = randomTheme;
                document.documentElement.style.setProperty('--bg-color', randomTheme.bg);
                document.documentElement.style.setProperty('--text-color', randomTheme.text);
                document.documentElement.style.setProperty('--border-color', randomTheme.border);
            }

            static async loadIconsData() {
                try {
                    const response = await fetch('icons.csv');
                    if (!response.ok) {
                        console.error(`Failed to load icons.csv: ${response.status} ${response.statusText}`);
                        return;
                    }
                    const csv = await response.text();
                    this.iconsData = this.parseCSV(csv);
                } catch (error) {
                    console.error('Error loading icons.csv:', error);
                }
            }

            static parseCSV(csv) {
                const lines = csv.split('\n').filter(line => line.trim());
                const headers = ['date', 'title', 'icon', 'url'];
                return lines.slice(1).map(line => {
                    const values = line.split(',').map(v => v.trim());
                    return headers.reduce((obj, header, i) => {
                        obj[header] = values[i] || '';
                        return obj;
                    }, {});
                });
            }

            static getIconsForDate(dateForIcons, keyword = '') {
                const icons = this.iconsData.filter(icon => icon.date === dateForIcons);
                if (icons.length === 0) return '';

                return icons.map(icon => {
                    const isUrl = icon.icon && (icon.icon.startsWith('http://') || icon.icon.startsWith('https://'));
                    const iconContent = isUrl
                        ? `<img src="${icon.icon}" alt="${icon.title}" class="icon-img">`
                        : `<span class="icon-emoji">${icon.icon}</span>`;
                    const tooltip = icon.title ? `<div class="tooltip">${icon.title}</div>` : '';
                    const url = icon.url ? `onclick="window.open('${icon.url}', '_blank')" style="cursor: pointer;"` : '';
                    const highlightClass = keyword && icon.title.toLowerCase().includes(keyword.toLowerCase()) ? 'highlight' : '';
                    return `<div class="icon ${highlightClass}" ${url}>${iconContent}${tooltip}</div>`;
                }).join('');
            }

            static executeLanternSearch() {
                if (this.diaryEntries.length === 0) return;

                const randomEntry = this.diaryEntries[Math.floor(Math.random() * this.diaryEntries.length)];
                const content = randomEntry.content;

                if (content.length < 2) return;
                const startIndex = Math.floor(Math.random() * (content.length - 2));
                const keywordLength = 2 + Math.floor(Math.random() * 2);
                let keyword = content.substring(startIndex, startIndex + keywordLength);

                const searchBox = document.querySelector('.search-box');
                searchBox.value = keyword;
                this.handleSearch(keyword);
            }

            static stopLanternMode() {
                if (!this.isLanternMode) return;
                this.isLanternMode = false;

                if (this.lanternModeInterval) {
                    clearInterval(this.lanternModeInterval);
                    this.lanternModeInterval = null;
                }

                const searchBox = document.querySelector('.search-box');
                searchBox.value = '';
                this.handleSearch('');
                searchBox.classList.remove('lantern-mode');
            }

            static startLanternMode() {
                if (this.isLanternMode) return;
                this.isLanternMode = true;

                const searchBox = document.querySelector('.search-box');
                searchBox.blur();
                searchBox.classList.add('lantern-mode');

                this.executeLanternSearch();
                this.lanternModeInterval = setInterval(() => {
                    this.executeLanternSearch();
                }, 3000);
            }

            static setupEventListeners() {
                const pageTitle = document.getElementById('pageTitle');
                const searchBox = document.querySelector('.search-box');

                pageTitle.addEventListener('click', () => this.toggleFakeMode());

                let pressTimer;
                pageTitle.addEventListener('mousedown', () => {
                    pressTimer = setTimeout(() => this.downloadDiaryAsText(), 1000);
                });
                pageTitle.addEventListener('mouseup', () => clearTimeout(pressTimer));
                pageTitle.addEventListener('mouseleave', () => clearTimeout(pressTimer));

                searchBox.addEventListener('input', (e) => this.handleSearch(e.target.value));

                document.addEventListener('keydown', (e) => this.handleKeyDown(e));

                window.addEventListener('hashchange', () => this.scrollToEntryFromHash());

                window.addEventListener('load', () => this.scrollToEntryFromHash());

                searchBox.addEventListener('dblclick', () => {
                    this.startLanternMode();
                });

                searchBox.addEventListener('click', () => {
                    this.stopLanternMode();
                });

                searchBox.addEventListener('focus', () => {
                    this.stopLanternMode();
                });
            }

            static async loadDiaryEntries(filename = 'entry.md') {
                try {
                    const response = await fetch(filename);
                    if (!response.ok) {
                        console.error(`Failed to load ${filename}: ${response.status} ${response.statusText}`);
                        return;
                    }
                    const text = await response.text();
                    this.renderEntries(text);
                } catch (error) {
                    console.error(`Error loading ${filename}:`, error);
                }
            }

            static renderEntries(text) {
                const container = document.getElementById('diaryContainer');
                container.innerHTML = '';
                this.diaryEntries = [];

                const entries = text.split('---').filter(entry => entry.trim());
                entries.reverse().forEach(entry => {
                    const dateMatch = entry.match(/date:\s*(.*)/);
                    const contentMatch = entry.match(/content:\s*\|\n([\s\S]*?)(?=\n---|\n$)/m);
                    if (!dateMatch || !contentMatch) return;

                    const yyyymmdd = dateMatch[1].trim();
                    const dateObj = DiaryUtils.formatJapaneseDate(yyyymmdd);
                    let contentLines = contentMatch[1]
                        .split('\n')
                        .map(line => line.replace(/^\s*\|?\s*/, ''))
                        .join('\n')
                        .trim();

                    if (this.currentSearchKeyword) {
                        contentLines = DiaryUtils.highlightText(contentLines, this.currentSearchKeyword);
                    }

                    const entryElement = document.createElement('div');
                    entryElement.className = 'diary-entry';
                    entryElement.id = yyyymmdd;

                    const dateForIcons = `${yyyymmdd.substring(0, 4)}/${yyyymmdd.substring(4, 6)}/${yyyymmdd.substring(6, 8)}`;
                    const iconsHTML = this.getIconsForDate(dateForIcons, this.currentSearchKeyword);

                    entryElement.innerHTML = `
                        <div class="date-container">
                            <div class="date" data-yyyymmdd="${yyyymmdd}">${dateObj.short}</div>
                            <div class="days-ago">${DiaryUtils.calculateDaysAgo(yyyymmdd)}</div>
                            ${iconsHTML}
                        </div>
                        <div class="content">${contentLines}</div>
                    `;
                    container.appendChild(entryElement);

                    this.diaryEntries.push({
                        yyyymmdd,
                        content: contentMatch[1].split('\n').map(line => line.replace(/^\s*\|?\s*/, '')).join('\n').trim(),
                        icons: this.iconsData.filter(icon => icon.date === dateForIcons)
                    });
                });

                this.setupDateClick();
                this.renderTimeline();
                this.updatePageTitle(entries.length);
                this.scrollToEntryFromHash();
            }

            static setupDateClick() {
                document.querySelectorAll('.date').forEach(dateElement => {
                    dateElement.addEventListener('click', () => {
                        const yyyymmdd = dateElement.getAttribute('data-yyyymmdd');
                        window.location.hash = yyyymmdd;
                        this.flashEntry(document.getElementById(yyyymmdd));
                    });
                });
            }

            static renderTimeline() {
                const timeline = document.getElementById('timeline');
                timeline.innerHTML = '';

                if (this.diaryEntries.length === 0) return;

                const sortedEntries = [...this.diaryEntries].sort((a, b) => a.yyyymmdd.localeCompare(b.yyyymmdd));
                const contentLengths = sortedEntries.map(entry => entry.content.length);
                const maxContentLength = Math.min(this.percentile95(contentLengths), 500);
                const baseHeight = 5;
                const heightRatio = 45 / maxContentLength;

                sortedEntries.forEach(entry => {
                    const container = document.createElement('div');
                    container.className = 'timeline-bar';
                    container.dataset.yyyymmdd = entry.yyyymmdd;

                    const innerBar = document.createElement('div');
                    innerBar.className = 'timeline-bar-inner';
                    const contentLength = Math.min(entry.content.length, maxContentLength);
                    const height = Math.max(baseHeight, contentLength * heightRatio);
                    innerBar.style.height = `${height}px`;

                    container.addEventListener('mouseover', () => {
                        window.location.hash = entry.yyyymmdd;
                        this.scrollToEntryFromHash();
                    });

                    container.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        window.location.hash = entry.yyyymmdd;
                        this.scrollToEntryFromHash();
                    });

                    container.appendChild(innerBar);
                    timeline.appendChild(container);
                });

                timeline.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = timeline.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const percent = x / rect.width;
                    const index = Math.floor((1 - percent) * sortedEntries.length);
                    if (index >= 0 && index < sortedEntries.length) {
                        window.location.hash = sortedEntries[index].yyyymmdd;
                        this.scrollToEntryFromHash();
                    }
                }, { passive: false });
            }

            static percentile95(arr) {
                const sorted = [...arr].sort((a, b) => a - b);
                const index = Math.floor(sorted.length * 0.95);
                return sorted[index];
            }

            static toggleFakeMode() {
                const title = document.querySelector('.page-title');
                const body = document.body;

                this.isFakeMode = !this.isFakeMode;
                title.textContent = this.isFakeMode ? '誤字ロマの嘘日記' : '誤字ロマの日記';
                title.classList.toggle('fake-mode', this.isFakeMode);
                body.classList.toggle('fake-mode', this.isFakeMode);

                if (this.isFakeMode) {
                    if (this.fakeEntriesCache) {
                        this.renderEntries(this.fakeEntriesCache);
                    } else {
                        this.loadDiaryEntries('fake.md');
                    }
                } else {
                    this.loadDiaryEntries('entry.md');
                }
            }

            static async preloadFakeEntries() {
                try {
                    const response = await fetch('fake.md');
                    if (response.ok) {
                        this.fakeEntriesCache = await response.text();
                    } else {
                        console.error(`Failed to preload fake.md: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Error preloading fake entries:', error);
                }
            }

            static scrollToEntryFromHash() {
                requestAnimationFrame(() => {
                    const hash = window.location.hash.substring(1);
                    const container = document.getElementById('diaryContainer');
                    const entries = document.querySelectorAll('.diary-entry');

                    if (hash && hash.match(/^\d{8}$/)) {
                        const entry = document.getElementById(hash);
                        if (entry) {
                            const entryRight = entry.offsetLeft + entry.clientWidth;
                            const containerWidth = container.clientWidth;
                            this.smoothScrollTo(container, entryRight - containerWidth);
                            this.flashEntry(entry);
                        }
                    } else if (entries.length > 0) {
                        const latestEntry = entries[0];
                        const entryRight = latestEntry.offsetLeft + latestEntry.clientWidth;
                        const containerWidth = container.clientWidth;
                        this.smoothScrollTo(container, entryRight - containerWidth);
                    }
                });
            }

            static smoothScrollTo(element, targetPosition, duration = 50) {
                const startPosition = element.scrollLeft;
                const startTime = performance.now();

                const animateScroll = (currentTime) => {
                    const elapsedTime = currentTime - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);
                    element.scrollLeft = startPosition + (targetPosition - startPosition) * progress;

                    if (progress < 1) {
                        requestAnimationFrame(animateScroll);
                    }
                };

                requestAnimationFrame(animateScroll);
            }

            static flashEntry(entry) {
                document.querySelectorAll('.diary-entry').forEach(el => {
                    if (el !== entry) {
                        Object.assign(el.style, {
                            transition: 'none',
                            fontWeight: '',
                            filter: 'brightness(1)',
                            color: ''
                        });
                    }
                });

                Object.assign(entry.style, {
                    transition: 'filter 0.2s ease, color 0.2s ease',
                    color: this.isFakeMode ? '#fff' : '#333333',
                    filter: 'brightness(2)'
                });

                setTimeout(() => {
                    Object.assign(entry.style, {
                        color: this.isFakeMode ? '#fff' : this.currentTheme.text,
                        filter: 'brightness(1)'
                    });
                }, 1200);
            }

            static handleKeyDown(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    const currentEntry = this.getCurrentEntry();
                    if (!currentEntry) return;

                    const direction = e.key === 'ArrowLeft' ? -1 : 1;
                    const nextEntry = this.getAdjacentEntry(currentEntry, direction);
                    if (nextEntry) {
                        window.location.hash = nextEntry.id;
                        this.scrollToEntryFromHash();
                    }
                } else if (e.key === 'Escape') {
                    if (window.location.hash) {
                        window.location.hash = '';
                    }
                }
            }

            static getCurrentEntry() {
                const hash = window.location.hash.substring(1);
                if (hash && hash.match(/^\d{8}$/)) {
                    return document.getElementById(hash);
                }
                const entries = document.querySelectorAll('.diary-entry');
                return entries.length > 0 ? entries[0] : null;
            }

            static getAdjacentEntry(currentEntry, direction) {
                const entries = document.querySelectorAll('.diary-entry');
                const currentIndex = Array.from(entries).indexOf(currentEntry);
                if (currentIndex === -1) return null;

                const nextIndex = currentIndex + direction;
                if (nextIndex < 0 || nextIndex >= entries.length) return null;
                return entries[nextIndex];
            }

            static handleSearch(keyword) {
                this.currentSearchKeyword = keyword;
                const keywordLower = keyword.toLowerCase();

                document.querySelectorAll('.diary-entry').forEach(entry => {
                    const contentElement = entry.querySelector('.content');
                    const dateContainer = entry.querySelector('.date-container');
                    const entryData = this.diaryEntries.find(e => e.yyyymmdd === entry.id);
                    if (!entryData) return;

                    const originalContent = entryData.content;
                    const contentLower = originalContent.toLowerCase();

                    // iconのtitleも検索対象に追加
                    const iconTitles = entryData.icons.map(icon => icon.title.toLowerCase());
                    const isMatch = contentLower.includes(keywordLower) ||
                        iconTitles.some(title => title.includes(keywordLower));

                    if (isMatch) {
                        entry.style.display = 'block';
                        if (keyword) {
                            contentElement.innerHTML = DiaryUtils.highlightText(originalContent, keyword);

                            // アイコンのハイライトを更新
                            const yyyymmdd = entry.id;
                            const dateForIcons = `${yyyymmdd.substring(0, 4)}/${yyyymmdd.substring(4, 6)}/${yyyymmdd.substring(6, 8)}`;
                            const iconsHTML = this.getIconsForDate(dateForIcons, keyword);
                            const newDateContainer = document.createElement('div');
                            newDateContainer.className = 'date-container';
                            newDateContainer.innerHTML = `
                                <div class="date" data-yyyymmdd="${yyyymmdd}">${dateContainer.querySelector('.date').textContent}</div>
                                <div class="days-ago">${dateContainer.querySelector('.days-ago').textContent}</div>
                                ${iconsHTML}
                            `;
                            dateContainer.replaceWith(newDateContainer);
                        } else {
                            contentElement.textContent = originalContent;
                        }
                    } else {
                        entry.style.display = 'none';
                    }
                });
            }

            static downloadDiaryAsText() {
                if (this.diaryEntries.length === 0) {
                    alert('ダウンロードする日記がありません。');
                    return;
                }

                const sortedEntries = [...this.diaryEntries].sort((a, b) => a.yyyymmdd.localeCompare(b.yyyymmdd));
                const oldestDate = sortedEntries[0].yyyymmdd;
                const newestDate = sortedEntries[sortedEntries.length - 1].yyyymmdd;
                const modePrefix = this.isFakeMode ? '嘘日記_' : '';
                const filename = `${modePrefix}誤字ロマの日記 ${oldestDate}-${newestDate}.txt`;

                let content = '';
                sortedEntries.forEach(entry => {
                    const dateObj = DiaryUtils.formatJapaneseDate(entry.yyyymmdd);
                    content += `${dateObj.long}\n${entry.content}\n\n`;
                });

                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            static updatePageTitle(count) {
                const pageTitle = document.getElementById('pageTitle');
                pageTitle.textContent = `誤字ロマの${count}日間`;
            }
        }

        // Initialize the app
        DiaryApp.init();
    </script>
</body>

</html>